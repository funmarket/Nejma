rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * Core Philosophy: This ruleset enforces a user-centric security model. Data is either
     * strictly private to a user (e.g., bookmarks), publicly readable but only writable by the
     * owner (e.g., videos, rentals), or shared between specific participants (e.g., bookings).
     * The primary source of truth for authorization is the user's authentication UID.
     *
     * Data Structure: Data is organized into top-level collections. User-specific, private
     * data like bookmarks is nested under the user's document (`/users/{userId}/bookmarks`) to
     * leverage path-based security.
     *
     * Key Security Decisions:
     * - Default Deny: All operations are denied by default.
     * - User Scoping: Users can only access and manage their own data. Listing other users'
     *   private subcollections is prohibited.
     * - Public vs. Private: Publicly readable content (like videos or gossip posts) still has
     *   strict, owner-only write permissions.
     * - Wallet Address vs. UID: Many entities use a `...Wallet` field for ownership. This is
     *   insecure for authorization as it cannot be reliably tied to `request.auth.uid`. These
     *   rules will flag these cases with CRITICAL comments and TODOs, defaulting to safer but
     *   more restrictive rules until the schema is updated to include a standard `userId` or
     *   `ownerId` field.
     *
     * Denormalization for Authorization: The rules are designed to avoid costly and slow `get()`
     * calls. For example, a `Video` document contains an `artistId` directly on it, allowing for
     * a simple ownership check (`resource.data.artistId == request.auth.uid`) without needing to
     * look up other documents.
     *
     * Structural Segregation: The use of a nested collection for `/users/{userId}/bookmarks` is a
     * clear example of structural segregation. It cleanly separates one user's private data from
     * another's, making security rules simple and queries efficient.
     */

    // ---------------------------
    // Helper Functions
    // ---------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the given userId.
     * Used for verifying ownership of a resource via its path.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the currently authenticated user's UID matches the given userId
     * AND if the document already exists.
     * Used for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
    
    /**
     * Checks if the authenticated user is the owner of an existing document
     * by looking at a specific field in the document's data.
     */
    function isDocumentOwner(docData) {
      return isSignedIn() && resource != null && request.auth.uid == docData.ownerId;
    }
    
    
    /**
     * Checks if an ownership field is immutable during an update.
     */
    function isOwnerFieldImmutable(fieldName) {
      return request.resource.data[fieldName] == resource.data[fieldName];
    }
    
    /**
     * Validates that the business user is creating the booking and that both
     * the artist and business can read it.
     */
    function isBookingParticipant(docData) {
      return isSignedIn() && (request.auth.uid == docData.artistId || request.auth.uid == docData.businessId);
    }
    
    /**
     * Validates that the business user is creating the adoption and that both
     * the artist and business can read it.
     */
    function isAdoptionParticipant(docData) {
      return isSignedIn() && (request.auth.uid == docData.artistId || request.auth.uid == docData.businessId);
    }

    // ---------------------------
    // Collection Rules
    // ---------------------------

    /**
     * @description Users can create their own profile, but can only update or delete their own. User profiles are publicly readable.
     * @path /users/{userId}
     * @allow (get) Any user, signed in or not, can view a user profile.
     * @allow (create) A new user with uid 'user-abc' creates their own profile document at /users/user-abc.
     * @deny (update) User 'user-abc' tries to update the profile document for 'user-xyz'.
     * @principle Enforces self-creation and ownership for user profiles.
     */
    match /users/{userId} {
      allow get, list: if true;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && isOwnerFieldImmutable('id');
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Videos are public and can be read by anyone. Only the artist who owns the video can create, update, or delete it.
     * @path /videos/{videoId}
     * @allow (get) Any user can view a video.
     * @allow (create) An authenticated user creates a video and sets the 'artistId' to their own UID.
     * @deny (update) A user tries to update a video where the 'artistId' does not match their UID.
     * @principle Public read access with strict owner-only writes.
     */
    match /videos/{videoId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.artistId == request.auth.uid;
      allow update: if isSignedIn() && resource != null && resource.data.artistId == request.auth.uid;
      allow delete: if isSignedIn() && resource != null && resource.data.artistId == request.auth.uid;
    }

    /**
     * @description A user's bookmarks are private. Only the user can view, create, or delete their own bookmarks.
     * @path /users/{userId}/bookmarks/{bookmarkId}
     * @allow (create) User 'user-abc' creates a new bookmark in their own subcollection at /users/user-abc/bookmarks/{bookmarkId}.
     * @deny (get) User 'user-xyz' attempts to read a bookmark from /users/user-abc/bookmarks/{bookmarkId}.
     * @deny (list) User 'user-xyz' attempts to list all bookmarks for 'user-abc'.
     * @principle Restricts access to a user's own data tree using path-based security.
     */
    match /users/{userId}/bookmarks/{bookmarkId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && isOwnerFieldImmutable('userId');
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Tips are publicly viewable. Any signed-in user can create a tip. Updates and deletes are disabled.
     * @path /tips/{tipId}
     * @allow (get) Any user can view the details of a tip transaction.
     * @allow (create) A signed-in user creates a new tip document.
     * @deny (update) No user can update a tip after it has been created.
     * @principle Public read with create-only access for authenticated users. Lacks sender validation.
     */
    match /tips/{tipId} {
      // CRITICAL: Cannot implement owner-only writes. The 'Tip' entity uses 'fromWallet' instead of a verifiable 'fromUserId'.
      // This allows any signed-in user to create a tip, but they could spoof the 'fromWallet' field.
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Add validation once schema is updated with 'fromUserId == request.auth.uid'.
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Bookings can be read by either the artist or the business. Only the business can create, update, or delete the booking.
     * @path /bookings/{bookingId}
     * @allow (get) The artist ('artistId') or the business ('businessId') can read the booking.
     * @allow (create) The business user creates a booking request for an artist.
     * @deny (get) A third-party user who is not the artist or business tries to read the booking.
     * @deny (delete) The artist tries to delete a booking they received.
     * @principle Implements a shared access model for a two-party transaction.
     */
    match /bookings/{bookingId} {
      allow get, list: if isBookingParticipant(resource.data);
      allow create: if isSignedIn() && request.resource.data.businessId == request.auth.uid;
      allow update: if isSignedIn() && resource != null && resource.data.businessId == request.auth.uid;
      allow delete: if isSignedIn() && resource != null && resource.data.businessId == request.auth.uid;
    }
    
    /**
     * @description Adoptions can be read by either the artist or the business. Only the business can create, update, or delete the adoption.
     * @path /adoptions/{adoptionId}
     * @allow (get) The artist ('artistId') or the business ('businessId') can read the adoption.
     * @allow (create) The business user creates an adoption request for an artist.
     * @deny (get) A third-party user who is not the artist or business tries to read the adoption.
     * @deny (delete) The artist tries to delete an adoption they received.
     * @principle Implements a shared access model for a two-party transaction.
     */
    match /adoptions/{adoptionId} {
      allow get, list: if isAdoptionParticipant(resource.data);
      allow create: if isSignedIn() && request.resource.data.businessId == request.auth.uid;
      allow update: if isSignedIn() && resource != null && resource.data.businessId == request.auth.uid;
      allow delete: if isSignedIn() && resource != null && resource.data.businessId == request.auth.uid;
    }

    /**
     * @description Video views are public. Any signed-in user can create a view record. Updates and deletes are disallowed.
     * @path /video_views/{videoViewId}
     * @allow (get) Any user can view the record of a video view.
     * @allow (create) A signed-in user creates a new video view record.
     * @deny (delete) No one can delete a video view record.
     * @principle Allows write access for any authenticated user for creating append-only logs. Lacks sender validation.
     */
    match /video_views/{videoViewId} {
      // CRITICAL: Cannot validate ownership. The 'VideoView' entity uses 'viewerId' (a wallet address) which cannot be tied to auth.uid.
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Add validation once schema includes 'viewerUserId == request.auth.uid'.
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Marketplace products are public. Writes are restricted until a proper ownership field is added.
     * @path /marketplace_products/{marketplaceProductId}
     * @allow (get) Anyone can view a marketplace product.
     * @deny (create) All write operations are currently blocked for security.
     * @principle Public read access, with writes disabled due to an insecure schema.
     */
    match /marketplace_products/{marketplaceProductId} {
      // CRITICAL: Cannot implement owner-only writes. The 'MarketplaceProduct' entity is missing an 'ownerId' or 'sellerId' field linked to auth.uid. It uses 'sellerWallet'.
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rental listings are public. Only the owner can create, update, or delete their listings.
     * @path /rentals/{rentalId}
     * @allow (list) Anyone can list all available rentals.
     * @allow (create) An authenticated user creates a new rental listing, setting 'ownerId' to their own UID.
     * @deny (update) A user tries to modify a rental listing where 'ownerId' is not their UID.
     * @principle Public read access with strict owner-only writes.
     */
    match /rentals/{rentalId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isDocumentOwner(resource.data) && isOwnerFieldImmutable('ownerId');
      allow delete: if isDocumentOwner(resource.data);
    }

    /**
     * @description Gossip posts are public. Writes are restricted until a proper ownership field is added.
     * @path /gossip_posts/{gossipPostId}
     * @allow (get) Anyone can read a gossip post.
     * @deny (create) All write operations are currently blocked for security.
     * @principle Public read access, with writes disabled due to an insecure schema.
     */
    match /gossip_posts/{gossipPostId} {
      // CRITICAL: Cannot implement owner-only writes. The 'GossipPost' entity is missing an 'authorId' field linked to auth.uid. It uses 'authorWallet'.
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
    
    /**
     * @description Gossip comments are public. Any signed-in user can create a comment. Updates/deletes are disabled for security.
     * @path /gossip_comments/{gossipCommentId}
     * @allow (get) Anyone can read comments.
     * @allow (create) A signed-in user posts a new comment.
     * @deny (update) No one can edit a comment after it's posted.
     * @principle Public read access, with create-only writes for authenticated users. Lacks author validation.
     */
    match /gossip_comments/{gossipCommentId} {
      // CRITICAL: Cannot implement owner-only writes. The 'GossipComment' entity uses 'authorWallet' instead of a verifiable 'authorId'.
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Add owner validation for update/delete once schema is updated with 'authorId'.
      allow update: if false;
      allow delete: if false;
    }
    
    /**
     * @description Gossip ratings are public. Any signed-in user can create a rating. Updates/deletes are disabled for security.
     * @path /gossip_ratings/{gossipRatingId}
     * @allow (get) Anyone can read ratings.
     * @allow (create) A signed-in user submits a new rating.
     * @deny (update) No one can edit a rating after it's submitted.
     * @principle Public read access, with create-only writes for authenticated users. Lacks author validation.
     */
    match /gossip_ratings/{gossipRatingId} {
      // CRITICAL: Cannot implement owner-only writes. The 'GossipRating' entity uses 'raterWallet' instead of a verifiable 'raterId'.
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Add owner validation for update/delete once schema is updated with 'raterId'.
      allow update: if false;
      allow delete: if false;
    }
    
    /**
     * @description Service ads are public, but cannot be modified as there is no ownership information.
     * @path /gossip_service_ads/{gossipServiceAdId}
     * @allow (get) Anyone can read service ads.
     * @deny (create) No one can create a new ad through security rules. This must be handled by a backend process.
     * @principle Public read-only data. All client write access is forbidden.
     */
    match /gossip_service_ads/{gossipServiceAdId} {
      // CRITICAL: The 'GossipServiceAd' entity is missing any ownership field (e.g., 'ownerId'). All writes are disallowed.
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
    
    /**
     * @description Follow relationships can be created and deleted by any signed-in user.
     * @path /gossip_user_follows/{gossipUserFollowsId}
     * @allow (get) Anyone can view follow relationships.
     * @allow (create) A signed-in user creates a follow relationship.
     * @deny (update) Follow relationships cannot be updated, only deleted and recreated.
     * @principle Allows authenticated users to manage relationship documents. Lacks creator validation.
     */
    match /gossip_user_follows/{gossipUserFollowsId} {
       // CRITICAL: Cannot validate ownership. 'followerWallet' cannot be tied to auth.uid. Any signed-in user can create/delete any follow record.
       // This rule assumes the client will correctly manage document IDs to delete the correct one.
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Add validation so request.resource.data.followerId == request.auth.uid
      allow update: if false;
      allow delete: if isSignedIn() && resource != null; // TODO: Add validation so resource.data.followerId == request.auth.uid
    }
    
    /**
     * @description Gossip messages are private and disabled. The current data model is insecure for direct client access.
     * @path /gossip_messages/{gossipMessageId}
     * @deny (get) No user can read any message.
     * @deny (create) No user can create any message.
     * @principle Disables access to a collection that cannot be secured with the current schema.
     */
    match /gossip_messages/{gossipMessageId} {
      // CRITICAL: This collection is entirely disabled. The use of 'fromWallet' and 'toWallet' without corresponding UIDs
      // makes it impossible to securely determine who can read or write messages without performing extra reads, which is
      // insecure and inefficient. The schema must be updated to include 'fromId' and 'toId' fields.
      allow get, list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

  }
}